<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>rAF + Scroll - Reverse | Scroll-Driven Animation</title>
		<link rel="stylesheet" href="../styles/common.css" />
		<link rel="stylesheet" href="../styles/demo.css" />
		<style>
			/*
			 * Bidirectional: Elements animate when entering viewport (any direction)
			 * rAF provides smooth frame-by-frame animation
			 */

			/* rAF controlled - no CSS transitions */
			.demo--raf .hero__cover,
			.demo--raf .feature-card,
			.demo--raf .stat-card {
				transition: none;
			}

			/* Direction indicator */
			.direction-indicator {
				position: fixed;
				top: 20px;
				right: 24px;
				padding: 8px 16px;
				background: var(--surface);
				border: 1px solid rgba(148, 163, 184, 0.2);
				border-radius: var(--radius-md);
				font-size: 13px;
				z-index: 100;
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.direction-indicator__arrow {
				font-size: 16px;
				transition: transform 0.2s, color 0.2s;
			}

			.direction-indicator.scroll-up .direction-indicator__arrow {
				transform: rotate(180deg);
				color: var(--accent);
			}

			.direction-indicator.scroll-down .direction-indicator__arrow {
				color: var(--text-muted);
			}
		</style>
	</head>
	<body class="demo--raf demo--reverse">
		<a class="skip-link" href="#main">Skip to content</a>

		<!-- Progress Bar -->
		<div class="progress-bar" aria-hidden="true">
			<div class="progress-bar__fill"></div>
		</div>

		<!-- Direction Indicator -->
		<div class="direction-indicator" id="directionIndicator" aria-live="polite">
			<span class="direction-indicator__arrow">â†“</span>
			<span class="direction-indicator__text">Scroll down first</span>
		</div>

		<!-- Header -->
		<header class="page-header container">
			<a href="../index.html" class="page-header__back">â† Back to demos</a>
			<h1 class="page-header__title">rAF + Scroll - Bidirectional</h1>
			<p class="page-header__desc">
				Smooth frame-by-frame animation on viewport entry/exit. Full control with rAF.
				<br /><span lang="ko">(ë·°í¬íŠ¸ ì§„ì…/ì´íƒˆ ì‹œ ë¶€ë“œëŸ¬ìš´ í”„ë ˆì„ ë‹¨ìœ„ ì• ë‹ˆë©”ì´ì…˜. rAFë¡œ ì™„ì „í•œ ì œì–´.)</span>
			</p>
			<span class="tag">rAF Bidirectional</span>
		</header>

		<!-- Main Content -->
		<main id="main">
			<!-- Hero Section -->
			<section class="hero" data-raf-hero>
				<div class="hero__sticky">
					<div class="hero__frame">
						<div class="hero__layer hero__base">
							<h2>Bidirectional Toggle</h2>
							<p>
								Scroll past this section, then come back.
								<br /><span lang="ko">(ì´ ì„¹ì…˜ì„ ì§€ë‚˜ì³¤ë‹¤ê°€ ëŒì•„ì˜¤ì„¸ìš”.)</span>
							</p>
						</div>
						<div class="hero__layer hero__cover">
							<h2>Welcome Back!</h2>
							<p>
								I appear whenever you enter this section!
								<br /><span lang="ko">(ì´ ì„¹ì…˜ì— ì§„ì…í•  ë•Œë§ˆë‹¤ ë‚˜íƒ€ë‚˜ìš”!)</span>
							</p>
						</div>
					</div>
				</div>
			</section>

			<!-- Features Section -->
			<section class="features">
				<div class="container">
					<header class="features__header">
						<h2>Features</h2>
						<p>
							Cards animate when entering viewport, reset when leaving.
							<br /><span lang="ko">(ë·°í¬íŠ¸ ì§„ì… ì‹œ ì¹´ë“œê°€ ì• ë‹ˆë©”ì´ì…˜ë˜ê³ , ì´íƒˆ ì‹œ ë¦¬ì…‹ë©ë‹ˆë‹¤.)</span>
						</p>
					</header>
					<div class="features__grid">
						<article class="feature-card" data-raf-card>
							<div class="feature-card__icon">ğŸ®</div>
							<h3>Full Control</h3>
							<p>
								rAF provides frame-by-frame animation control.
								<br /><span lang="ko">(rAFë¡œ í”„ë ˆì„ ë‹¨ìœ„ ì• ë‹ˆë©”ì´ì…˜ ì œì–´.)</span>
							</p>
						</article>
						<article class="feature-card" data-raf-card>
							<div class="feature-card__icon">ğŸ“</div>
							<h3>Custom Easing</h3>
							<p>
								Smooth easing functions for natural motion.
								<br /><span lang="ko">(ìì—°ìŠ¤ëŸ¬ìš´ ì›€ì§ì„ì„ ìœ„í•œ ì´ì§• í•¨ìˆ˜.)</span>
							</p>
						</article>
						<article class="feature-card" data-raf-card>
							<div class="feature-card__icon">âš¡</div>
							<h3>Smooth 60fps</h3>
							<p>
								requestAnimationFrame ensures smooth animation.
								<br /><span lang="ko">(rAFê°€ ë¶€ë“œëŸ¬ìš´ ì• ë‹ˆë©”ì´ì…˜ ë³´ì¥.)</span>
							</p>
						</article>
					</div>
				</div>
			</section>

			<!-- Stats Section -->
			<section class="stats">
				<div class="container">
					<header class="stats__header">
						<h2>By the Numbers</h2>
						<p>
							Counters animate smoothly on viewport entry.
							<br /><span lang="ko">(ë·°í¬íŠ¸ ì§„ì… ì‹œ ì¹´ìš´í„°ê°€ ë¶€ë“œëŸ½ê²Œ ì• ë‹ˆë©”ì´ì…˜ë©ë‹ˆë‹¤.)</span>
						</p>
					</header>
					<div class="stats__grid">
						<div class="stat-card" data-raf-stat data-value="60">
							<div class="stat-card__value">0</div>
							<div class="stat-card__label">Target FPS</div>
						</div>
						<div class="stat-card" data-raf-stat data-value="100">
							<div class="stat-card__value">0%</div>
							<div class="stat-card__label">Browser Support</div>
						</div>
						<div class="stat-card" data-raf-stat data-value="16">
							<div class="stat-card__value">0ms</div>
							<div class="stat-card__label">Frame Budget</div>
						</div>
					</div>
				</div>
			</section>

			<!-- Implementation Info -->
			<section class="impl-info">
				<div class="container">
					<div class="impl-info__grid">
						<div class="impl-info__box">
							<h3>Implementation</h3>
							<ul>
								<li>Track element visibility with <code>getBoundingClientRect</code></li>
								<li>Increase progress when in viewport</li>
								<li>Decrease progress when out of viewport</li>
								<li>Apply easing for smooth animation feel</li>
							</ul>
						</div>
						<div class="impl-info__box">
							<h3>Browser Support</h3>
							<ul>
								<li>Chrome âœ… (all versions)</li>
								<li>Firefox âœ… (all versions)</li>
								<li>Safari âœ… (all versions)</li>
								<li>Edge âœ… (all versions)</li>
								<li>Universal JavaScript support</li>
							</ul>
						</div>
						<div class="impl-info__box">
							<h3>Use Cases</h3>
							<ul>
								<li>Repeatable scroll animations</li>
								<li>Interactive timelines</li>
								<li>Product showcases</li>
								<li>Complex multi-element choreography</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
		</main>

		<!-- Footer -->
		<footer class="page-footer">
			<div class="container">
				<p>Scroll-Driven Animation Demo - Reverse Direction</p>
			</div>
		</footer>

		<script>
			(function () {
				const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

				const progressFill = document.querySelector('.progress-bar__fill');
				const directionIndicator = document.getElementById('directionIndicator');
				const directionText = directionIndicator.querySelector('.direction-indicator__text');
				const heroCover = document.querySelector('.hero__cover');
				const heroSection = document.querySelector('[data-raf-hero]');
				const cards = document.querySelectorAll('[data-raf-card]');
				const stats = document.querySelectorAll('[data-raf-stat]');

				let lastScrollY = window.scrollY;
				let ticking = false;

				// Element progress tracking (0 = hidden, 1 = visible)
				const elementProgress = new Map();
				cards.forEach(card => elementProgress.set(card, 0));
				stats.forEach(stat => elementProgress.set(stat, 0));
				let heroProgress = 0;

				const clamp = (val) => Math.min(1, Math.max(0, val));
				const easeOut = (t) => 1 - Math.pow(1 - t, 3);

				// Handle reduced motion
				if (prefersReducedMotion) {
					heroCover.style.transform = 'translateY(0)';
					cards.forEach(card => {
						card.style.opacity = '1';
						card.style.transform = 'none';
					});
					stats.forEach(stat => {
						stat.style.opacity = '1';
						stat.style.transform = 'none';
						const value = stat.dataset.value;
						const label = stat.querySelector('.stat-card__label').textContent;
						const valueEl = stat.querySelector('.stat-card__value');
						if (label.includes('FPS')) valueEl.textContent = value;
						else if (label.includes('%')) valueEl.textContent = value + '%';
						else if (label.includes('ms')) valueEl.textContent = value + 'ms';
					});
					return;
				}

				// Initialize hidden state
				heroCover.style.transform = 'translateY(-100%)';
				cards.forEach(card => {
					card.style.opacity = '0';
					card.style.transform = 'translateY(40px)';
				});
				stats.forEach(stat => {
					stat.style.opacity = '0';
					stat.style.transform = 'scale(0.9)';
				});

				function update() {
					ticking = false;
					const vh = window.innerHeight;
					const currentScrollY = window.scrollY;
					const docHeight = document.documentElement.scrollHeight - vh;

					// Progress bar (always updates)
					const scrollProgress = docHeight > 0 ? currentScrollY / docHeight : 0;
					progressFill.style.transform = `scaleX(${scrollProgress})`;

					// Detect direction (for indicator only)
					const isScrollingUp = currentScrollY < lastScrollY;

					// Update direction indicator
					if (isScrollingUp) {
						directionIndicator.classList.add('scroll-up');
						directionIndicator.classList.remove('scroll-down');
						directionText.textContent = 'Scrolling UP';
					} else {
						directionIndicator.classList.add('scroll-down');
						directionIndicator.classList.remove('scroll-up');
						directionText.textContent = 'Scrolling DOWN';
					}

					// Hero cover - bidirectional: show when in view, hide when out
					if (heroSection) {
						const heroRect = heroSection.getBoundingClientRect();
						const inView = heroRect.top < vh * 0.7 && heroRect.bottom > vh * 0.3;

						if (inView) {
							heroProgress = clamp(heroProgress + 0.08);
						} else {
							heroProgress = clamp(heroProgress - 0.08);
						}

						const coverY = (1 - easeOut(heroProgress)) * -100;
						heroCover.style.transform = `translateY(${coverY}%)`;
					}

					// Feature cards - bidirectional: animate in when visible, out when not
					cards.forEach((card) => {
						const rect = card.getBoundingClientRect();
						const inView = rect.top < vh * 0.85 && rect.bottom > vh * 0.15;
						let progress = elementProgress.get(card);

						if (inView) {
							progress = clamp(progress + 0.06);
						} else {
							progress = clamp(progress - 0.06);
						}

						elementProgress.set(card, progress);
						const eased = easeOut(progress);

						card.style.opacity = eased;
						card.style.transform = `translateY(${(1 - eased) * 40}px)`;
					});

					// Stat cards - bidirectional: animate in when visible, out when not
					stats.forEach((stat) => {
						const rect = stat.getBoundingClientRect();
						const inView = rect.top < vh * 0.85 && rect.bottom > vh * 0.15;
						let progress = elementProgress.get(stat);

						if (inView) {
							progress = clamp(progress + 0.06);
						} else {
							progress = clamp(progress - 0.06);
						}

						elementProgress.set(stat, progress);
						const eased = easeOut(progress);

						stat.style.opacity = eased;
						stat.style.transform = `scale(${0.9 + eased * 0.1})`;

						// Counter animation - interpolates based on progress
						const target = parseFloat(stat.dataset.value);
						const current = Math.round(target * eased);
						const label = stat.querySelector('.stat-card__label').textContent;
						const valueEl = stat.querySelector('.stat-card__value');

						if (label.includes('FPS')) valueEl.textContent = current;
						else if (label.includes('%')) valueEl.textContent = current + '%';
						else if (label.includes('ms')) valueEl.textContent = current + 'ms';
					});

					lastScrollY = currentScrollY;

					// Continue animation if elements are transitioning
					const stillAnimating = [...elementProgress.values()].some(p => p > 0 && p < 1) ||
						(heroProgress > 0 && heroProgress < 1);
					if (stillAnimating) {
						requestAnimationFrame(update);
					}
				}

				function onScroll() {
					if (!ticking) {
						ticking = true;
						requestAnimationFrame(update);
					}
				}

				window.addEventListener('scroll', onScroll, { passive: true });
				window.addEventListener('resize', onScroll, { passive: true });
				update();
			})();
		</script>
	</body>
</html>
