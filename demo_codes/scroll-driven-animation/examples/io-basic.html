<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Intersection Observer - Basic | Scroll-Driven Animation</title>
		<link rel="stylesheet" href="../styles/common.css" />
		<link rel="stylesheet" href="../styles/demo.css" />
	</head>
	<body class="demo--io demo--basic">
		<a class="skip-link" href="#main">Skip to content</a>

		<!-- Progress Bar -->
		<div class="progress-bar" aria-hidden="true">
			<div class="progress-bar__fill"></div>
		</div>

		<!-- Header -->
		<header class="page-header container">
			<a href="../index.html" class="page-header__back">â† Back to demos</a>
			<h1 class="page-header__title">Intersection Observer - Basic</h1>
			<p class="page-header__desc">
				Elements animate when they enter the viewport using IntersectionObserver API.
				<br /><span lang="ko">(IntersectionObserver APIë¡œ ë·°í¬íŠ¸ ì§„ì… ì‹œ ì• ë‹ˆë©”ì´ì…˜ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.)</span>
			</p>
			<span class="tag">IntersectionObserver</span>
		</header>

		<!-- Main Content -->
		<main id="main">
			<!-- Hero Section -->
			<section class="hero">
				<div class="hero__sticky">
					<div class="hero__frame">
						<div class="hero__layer hero__base">
							<h2>Welcome</h2>
							<p>
								The cover lifts when the section is 40% visible.
								<br /><span lang="ko">(ì„¹ì…˜ì´ 40% ë³´ì´ë©´ ì»¤ë²„ê°€ ì˜¬ë¼ê°‘ë‹ˆë‹¤.)</span>
							</p>
						</div>
						<div class="hero__layer hero__cover" data-io-hero>
							<h2>Scroll Down</h2>
							<p>
								Intersection Observer detects visibility.
								<br /><span lang="ko">(Intersection Observerê°€ ê°€ì‹œì„±ì„ ê°ì§€í•©ë‹ˆë‹¤.)</span>
							</p>
						</div>
					</div>
				</div>
			</section>

			<!-- Features Section -->
			<section class="features">
				<div class="container">
					<header class="features__header">
						<h2>Features</h2>
						<p>
							Cards appear when they enter the viewport.
							<br /><span lang="ko">(ì¹´ë“œê°€ ë·°í¬íŠ¸ì— ë“¤ì–´ì˜¤ë©´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.)</span>
						</p>
					</header>
					<div class="features__grid">
						<article class="feature-card" data-io-card>
							<div class="feature-card__icon">ğŸ‘ï¸</div>
							<h3>Visibility Detection</h3>
							<p>
								Efficiently detects when elements enter or leave viewport.
								<br /><span lang="ko">(ìš”ì†Œì˜ ë·°í¬íŠ¸ ì§„ì…/ì´íƒˆì„ íš¨ìœ¨ì ìœ¼ë¡œ ê°ì§€.)</span>
							</p>
						</article>
						<article class="feature-card" data-io-card>
							<div class="feature-card__icon">ğŸšï¸</div>
							<h3>Threshold Control</h3>
							<p>
								Set exactly how much of element must be visible to trigger.
								<br /><span lang="ko">(íŠ¸ë¦¬ê±°í•  ê°€ì‹œ ë¹„ìœ¨ì„ ì •í™•íˆ ì„¤ì • ê°€ëŠ¥.)</span>
							</p>
						</article>
						<article class="feature-card" data-io-card>
							<div class="feature-card__icon">ğŸ“±</div>
							<h3>Wide Support</h3>
							<p>
								Works in all modern browsers including Safari.
								<br /><span lang="ko">(Safari í¬í•¨ ëª¨ë“  ìµœì‹  ë¸Œë¼ìš°ì € ì§€ì›.)</span>
							</p>
						</article>
					</div>
				</div>
			</section>

			<!-- Stats Section -->
			<section class="stats">
				<div class="container">
					<header class="stats__header">
						<h2>By the Numbers</h2>
						<p>
							Stats pop in when visible.
							<br /><span lang="ko">(ë³´ì´ë©´ í†µê³„ê°€ íŒì—…ë©ë‹ˆë‹¤.)</span>
						</p>
					</header>
					<div class="stats__grid">
						<div class="stat-card" data-io-stat>
							<div class="stat-card__value">97%</div>
							<div class="stat-card__label">Browser Support</div>
						</div>
						<div class="stat-card" data-io-stat>
							<div class="stat-card__value">Async</div>
							<div class="stat-card__label">Non-blocking</div>
						</div>
						<div class="stat-card" data-io-stat>
							<div class="stat-card__value">Light</div>
							<div class="stat-card__label">Performance</div>
						</div>
					</div>
				</div>
			</section>

			<!-- Implementation Info -->
			<section class="impl-info">
				<div class="container">
					<div class="impl-info__grid">
						<div class="impl-info__box">
							<h3>Implementation</h3>
							<ul>
								<li><code>IntersectionObserver</code> watches element visibility</li>
								<li><code>threshold: 0.4</code> triggers at 40% visibility</li>
								<li>Toggle CSS class to trigger transition</li>
								<li>One observer can watch multiple elements</li>
							</ul>
						</div>
						<div class="impl-info__box">
							<h3>Browser Support</h3>
							<ul>
								<li>Chrome 51+ âœ…</li>
								<li>Firefox 55+ âœ…</li>
								<li>Safari 12.1+ âœ…</li>
								<li>Edge 15+ âœ…</li>
								<li>Polyfill available for older browsers</li>
							</ul>
						</div>
						<div class="impl-info__box">
							<h3>Performance</h3>
							<ul>
								<li>Runs asynchronously (non-blocking)</li>
								<li>Browser-optimized visibility calculations</li>
								<li>More efficient than scroll event listeners</li>
								<li>Minimal CPU usage when idle</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
		</main>

		<!-- Footer -->
		<footer class="page-footer">
			<div class="container">
				<p>Scroll-Driven Animation Demo</p>
			</div>
		</footer>

		<script>
			(function () {
				const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

				// Progress bar
				const progressFill = document.querySelector('.progress-bar__fill');
				function updateProgress() {
					const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
					const progress = scrollHeight > 0 ? window.scrollY / scrollHeight : 0;
					progressFill.style.transform = `scaleX(${progress})`;
				}
				window.addEventListener('scroll', updateProgress, { passive: true });
				updateProgress();

				// Show all immediately if reduced motion
				if (prefersReducedMotion) {
					document.querySelector('[data-io-hero]').style.transform = 'translateY(-100%)';
					document.querySelectorAll('[data-io-card], [data-io-stat]').forEach(el => {
						el.classList.add('is-visible');
					});
					return;
				}

				// Hero observer
				const heroObserver = new IntersectionObserver(
					(entries) => {
						entries.forEach(entry => {
							const cover = entry.target;
							if (entry.isIntersecting) {
								cover.style.transform = 'translateY(-100%)';
							} else {
								cover.style.transform = 'translateY(0)';
							}
						});
					},
					{ threshold: 0.4 }
				);

				const heroCover = document.querySelector('[data-io-hero]');
				const heroSection = heroCover?.closest('.hero');
				if (heroSection) heroObserver.observe(heroSection);

				// Cards & Stats observer
				const elementsObserver = new IntersectionObserver(
					(entries) => {
						entries.forEach(entry => {
							entry.target.classList.toggle('is-visible', entry.isIntersecting);
						});
					},
					{ threshold: 0.3 }
				);

				document.querySelectorAll('[data-io-card], [data-io-stat]').forEach(el => {
					elementsObserver.observe(el);
				});
			})();
		</script>
	</body>
</html>
