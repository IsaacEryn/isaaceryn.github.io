<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>IntersectionObserver - Basic</title>
		<link rel="stylesheet" href="../../assets/styles/demo-common.css" />
		<link rel="stylesheet" href="../styles/demo-shared.css" />
		<link rel="stylesheet" href="../styles/intersection-observer.css" />
		<style>
			:root {
				--panel: #0f172a;
				--accent: #f59e0b;
				--accent-2: #f97316;
			}
			body {
				background: linear-gradient(180deg, #0b0d12 0%, #0f172a 100%);
			}
		</style>
	</head>
	<body class="page demo demo--io demo--basic">
		<a class="skip-link" href="#content">Skip to content</a>
		<div class="progress" aria-hidden="true">
			<div class="progress-bar" data-progress></div>
		</div>
		<header class="page-header container">
			<a href="../index.html">← Back to list</a>
			<h1>IntersectionObserver - Basic</h1>
			<p class="pill">IntersectionObserver</p>
			<p class="note">
				Basic: step toggle on scroll.
				<br /><span lang="ko">(기본: 스크롤에 따른 단계 토글.)</span>
			</p>
		</header>
		<main id="content" class="page-main">
			<section class="scene scene-cover" data-cover-trigger>
				<div class="scene-intro container">
					<h2>Cover lift</h2>
					<p>
						Full cover moves up. Base screen stays.
						<br /><span lang="ko">(전체 화면 커버가 올라가고, 뒤의 화면은 고정됩니다.)</span>
					</p>
				</div>
				<div class="cover-track" data-cover-track>
					<div class="cover-frame">
						<div class="screen screen--base">
							<span class="screen-title">Base screen</span>
							<span class="screen-sub">Pinned</span>
						</div>
						<div class="screen screen--cover" data-cover>
							<span class="screen-title">Cover screen</span>
							<span class="screen-sub">Moves up</span>
						</div>
					</div>
				</div>
			</section>
			<section class="scene scene-rail">
				<div class="container stack">
					<div class="scene-intro">
						<h2>Info rail</h2>
						<p>
							Cards rise with scroll.
							<br /><span lang="ko">(카드가 스크롤에 맞춰 올라옵니다.)</span>
						</p>
					</div>
					<div class="rail" data-rail>
						<article class="rail-card" data-rail-card>
							<h3>Step 1</h3>
							<p>Pin the base.</p>
						</article>
						<article class="rail-card" data-rail-card>
							<h3>Step 2</h3>
							<p>Lift the cover.</p>
						</article>
						<article class="rail-card" data-rail-card>
							<h3>Step 3</h3>
							<p>Reveal detail.</p>
						</article>
					</div>
				</div>
			</section>
			<section class="scene scene-finale">
				<div class="container panel">
					<h2>Finish</h2>
					<p>
						Progress bar tracks the page.
						<br /><span lang="ko">(상단 바는 페이지 진행률을 보여줍니다.)</span>
					</p>
					<p class="note">Scroll up to compare.</p>
				</div>
			</section>
			<section class="scene">
				<div class="container panel">
					<h2>Support & performance</h2>
					<ul>
						<li>
							Support: IntersectionObserver.
							<br /><span lang="ko">(지원: IntersectionObserver 필요.)</span>
						</li>
						<li>
							Behavior: step toggle, no smooth progress.
							<br /><span lang="ko">(동작: 단계 토글, 연속 진행 없음.)</span>
						</li>
						<li>
							Performance: event-driven, light.
							<br /><span lang="ko">(성능: 이벤트 기반, 가볍게 동작.)</span>
						</li>
					</ul>
				</div>
			</section>
		</main>
		<script>
			const progressBar = document.querySelector("[data-progress]");
			const coverTrigger = document.querySelector("[data-cover-trigger]");
			const cover = document.querySelector("[data-cover]");
			const cards = document.querySelectorAll("[data-rail-card]");
			const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
			let ticking = false;

			const updateProgress = () => {
				const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
				const progress = maxScroll > 0 ? window.scrollY / maxScroll : 0;
				if (progressBar) progressBar.style.transform = `scaleX(${progress})`;
			};

			const onScroll = () => {
				if (ticking) return;
				ticking = true;
				window.requestAnimationFrame(() => {
					updateProgress();
					ticking = false;
				});
			};

			window.addEventListener("scroll", onScroll, { passive: true });
			window.addEventListener("resize", onScroll);
			updateProgress();

			const revealAll = () => {
				if (cover) cover.classList.add("is-active");
				cards.forEach((card) => card.classList.add("is-active"));
			};

			if (reduceMotion) {
				revealAll();
			} else {
				const observer = new IntersectionObserver(
					(entries) => {
						entries.forEach((entry) => {
							if (entry.target === coverTrigger) {
								if (cover) cover.classList.toggle("is-active", entry.isIntersecting);
								return;
							}
							entry.target.classList.toggle("is-active", entry.isIntersecting);
						});
					},
					{ threshold: 0.35 }
				);

				if (coverTrigger) observer.observe(coverTrigger);
				cards.forEach((card) => observer.observe(card));
			}
		</script>
	</body>
</html>
