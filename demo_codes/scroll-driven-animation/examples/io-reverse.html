<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Intersection Observer - Reverse | Scroll-Driven Animation</title>
		<link rel="stylesheet" href="../styles/common.css" />
		<link rel="stylesheet" href="../styles/demo.css" />
		<style>
			/*
			 * Bidirectional: Elements animate when entering viewport (any direction)
			 * and reset when leaving viewport
			 */

			/* Initial state: hidden */
			.hero__cover {
				transform: translateY(-100%);
			}

			.feature-card,
			.stat-card {
				opacity: 0;
				transform: translateY(40px);
			}

			/* Transitions */
			.hero__cover {
				transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
			}

			.feature-card,
			.stat-card {
				transition: opacity 0.5s ease, transform 0.5s ease;
			}

			/* Visible state - when in view (bidirectional) */
			.hero.in-view .hero__cover {
				transform: translateY(0);
			}

			.feature-card.in-view,
			.stat-card.in-view {
				opacity: 1;
				transform: translateY(0);
			}

			/* Direction indicator */
			.direction-indicator {
				position: fixed;
				top: 20px;
				right: 24px;
				padding: 8px 16px;
				background: var(--surface);
				border: 1px solid rgba(148, 163, 184, 0.2);
				border-radius: var(--radius-md);
				font-size: 13px;
				z-index: 100;
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.direction-indicator__arrow {
				font-size: 16px;
				transition: transform 0.2s, color 0.2s;
			}

			.direction-indicator.scroll-up .direction-indicator__arrow {
				transform: rotate(180deg);
				color: var(--accent);
			}

			.direction-indicator.scroll-down .direction-indicator__arrow {
				color: var(--text-muted);
			}

			@media (prefers-reduced-motion: reduce) {
				.hero__cover,
				.feature-card,
				.stat-card {
					transition: none;
					opacity: 1;
					transform: none;
				}
			}
		</style>
	</head>
	<body class="demo--io demo--reverse">
		<a class="skip-link" href="#main">Skip to content</a>

		<!-- Progress Bar -->
		<div class="progress-bar" aria-hidden="true">
			<div class="progress-bar__fill"></div>
		</div>

		<!-- Direction Indicator -->
		<div class="direction-indicator" aria-live="polite">
			<span class="direction-indicator__arrow">â†“</span>
			<span class="direction-indicator__text">Scroll down first</span>
		</div>

		<!-- Header -->
		<header class="page-header container">
			<a href="../index.html" class="page-header__back">â† Back to demos</a>
			<h1 class="page-header__title">Intersection Observer - Bidirectional</h1>
			<p class="page-header__desc">
				Elements animate when entering viewport, reset when leaving. Works both directions.
				<br /><span lang="ko">(ë·°í¬íŠ¸ ì§„ì… ì‹œ ì• ë‹ˆë©”ì´ì…˜, ì´íƒˆ ì‹œ ë¦¬ì…‹. ì–‘ë°©í–¥ ë™ì‘.)</span>
			</p>
			<span class="tag">IO Bidirectional</span>
		</header>

		<!-- Main Content -->
		<main id="main">
			<!-- Hero Section -->
			<section class="hero" data-io-hero>
				<div class="hero__sticky">
					<div class="hero__frame">
						<div class="hero__layer hero__base">
							<h2>Bidirectional Toggle</h2>
							<p>
								Scroll past this section, then come back.
								<br /><span lang="ko">(ì´ ì„¹ì…˜ì„ ì§€ë‚˜ì³¤ë‹¤ê°€ ëŒì•„ì˜¤ì„¸ìš”.)</span>
							</p>
						</div>
						<div class="hero__layer hero__cover">
							<h2>Welcome Back!</h2>
							<p>
								I appear whenever you enter this section!
								<br /><span lang="ko">(ì´ ì„¹ì…˜ì— ì§„ì…í•  ë•Œë§ˆë‹¤ ë‚˜íƒ€ë‚˜ìš”!)</span>
							</p>
						</div>
					</div>
				</div>
			</section>

			<!-- Features Section -->
			<section class="features">
				<div class="container">
					<header class="features__header">
						<h2>Features</h2>
						<p>
							Cards animate when entering viewport, reset when leaving.
							<br /><span lang="ko">(ë·°í¬íŠ¸ ì§„ì… ì‹œ ì¹´ë“œê°€ ì• ë‹ˆë©”ì´ì…˜ë˜ê³ , ì´íƒˆ ì‹œ ë¦¬ì…‹ë©ë‹ˆë‹¤.)</span>
						</p>
					</header>
					<div class="features__grid">
						<article class="feature-card" data-io-card>
							<div class="feature-card__icon">ğŸ‘ï¸</div>
							<h3>Viewport Detection</h3>
							<p>
								IntersectionObserver tracks element visibility.
								<br /><span lang="ko">(IOê°€ ìš”ì†Œì˜ ê°€ì‹œì„±ì„ ì¶”ì í•©ë‹ˆë‹¤.)</span>
							</p>
						</article>
						<article class="feature-card" data-io-card>
							<div class="feature-card__icon">ğŸ”„</div>
							<h3>Bidirectional</h3>
							<p>
								Works when scrolling both up and down.
								<br /><span lang="ko">(ìœ„ì•„ë˜ ìŠ¤í¬ë¡¤ ëª¨ë‘ì—ì„œ ë™ì‘.)</span>
							</p>
						</article>
						<article class="feature-card" data-io-card>
							<div class="feature-card__icon">â™»ï¸</div>
							<h3>Auto Reset</h3>
							<p>
								Elements reset when leaving viewport.
								<br /><span lang="ko">(ë·°í¬íŠ¸ ì´íƒˆ ì‹œ ìš”ì†Œê°€ ë¦¬ì…‹ë¨.)</span>
							</p>
						</article>
					</div>
				</div>
			</section>

			<!-- Stats Section -->
			<section class="stats">
				<div class="container">
					<header class="stats__header">
						<h2>By the Numbers</h2>
						<p>
							Stats animate on viewport entry.
							<br /><span lang="ko">(ë·°í¬íŠ¸ ì§„ì… ì‹œ í†µê³„ê°€ ì• ë‹ˆë©”ì´ì…˜ë©ë‹ˆë‹¤.)</span>
						</p>
					</header>
					<div class="stats__grid">
						<div class="stat-card" data-io-stat>
							<div class="stat-card__value">97%</div>
							<div class="stat-card__label">IO Support</div>
						</div>
						<div class="stat-card" data-io-stat>
							<div class="stat-card__value">â†‘</div>
							<div class="stat-card__label">Trigger Direction</div>
						</div>
						<div class="stat-card" data-io-stat>
							<div class="stat-card__value">Light</div>
							<div class="stat-card__label">Performance</div>
						</div>
					</div>
				</div>
			</section>

			<!-- Implementation Info -->
			<section class="impl-info">
				<div class="container">
					<div class="impl-info__grid">
						<div class="impl-info__box">
							<h3>Implementation</h3>
							<ul>
								<li>IO tracks element visibility with <code>threshold</code></li>
								<li>Toggle <code>.in-view</code> class on intersection</li>
								<li>CSS transitions handle animation</li>
								<li>Elements reset when leaving viewport</li>
							</ul>
						</div>
						<div class="impl-info__box">
							<h3>Browser Support</h3>
							<ul>
								<li>Chrome 51+ âœ…</li>
								<li>Firefox 55+ âœ…</li>
								<li>Safari 12.1+ âœ…</li>
								<li>Edge 15+ âœ…</li>
								<li>Excellent cross-browser support</li>
							</ul>
						</div>
						<div class="impl-info__box">
							<h3>Use Cases</h3>
							<ul>
								<li>Repeatable scroll animations</li>
								<li>Interactive storytelling</li>
								<li>Product showcases</li>
								<li>Scroll-triggered reveals</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
		</main>

		<!-- Footer -->
		<footer class="page-footer">
			<div class="container">
				<p>Scroll-Driven Animation Demo - Reverse Direction</p>
			</div>
		</footer>

		<script>
			(function () {
				const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
				const progressFill = document.querySelector('.progress-bar__fill');
				const directionIndicator = document.querySelector('.direction-indicator');
				const directionText = document.querySelector('.direction-indicator__text');
				const heroSection = document.querySelector('[data-io-hero]');
				const cards = document.querySelectorAll('[data-io-card]');
				const stats = document.querySelectorAll('[data-io-stat]');

				let lastScrollY = window.scrollY;

				// Handle reduced motion
				if (prefersReducedMotion) {
					if (heroSection) heroSection.classList.add('in-view');
					cards.forEach(el => el.classList.add('in-view'));
					stats.forEach(el => el.classList.add('in-view'));
					return;
				}

				// Progress bar
				function updateProgress() {
					const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
					const progress = scrollHeight > 0 ? window.scrollY / scrollHeight : 0;
					progressFill.style.transform = `scaleX(${progress})`;
				}

				// Scroll direction detection (for indicator only)
				function updateScrollDirection() {
					const currentScrollY = window.scrollY;
					const isScrollingUp = currentScrollY < lastScrollY;

					if (isScrollingUp) {
						directionIndicator.classList.add('scroll-up');
						directionIndicator.classList.remove('scroll-down');
						directionText.textContent = 'Scrolling UP';
					} else {
						directionIndicator.classList.add('scroll-down');
						directionIndicator.classList.remove('scroll-up');
						directionText.textContent = 'Scrolling DOWN';
					}

					lastScrollY = currentScrollY;
				}

				// IntersectionObserver for hero section
				const heroObserver = new IntersectionObserver(
					(entries) => {
						entries.forEach(entry => {
							entry.target.classList.toggle('in-view', entry.isIntersecting);
						});
					},
					{ threshold: 0.3 }
				);

				if (heroSection) heroObserver.observe(heroSection);

				// IntersectionObserver for cards and stats (bidirectional toggle)
				const elementsObserver = new IntersectionObserver(
					(entries) => {
						entries.forEach(entry => {
							entry.target.classList.toggle('in-view', entry.isIntersecting);
						});
					},
					{ threshold: 0.3 }
				);

				cards.forEach(el => elementsObserver.observe(el));
				stats.forEach(el => elementsObserver.observe(el));

				// Scroll event
				window.addEventListener('scroll', () => {
					updateProgress();
					updateScrollDirection();
				}, { passive: true });

				updateProgress();
			})();
		</script>
	</body>
</html>
